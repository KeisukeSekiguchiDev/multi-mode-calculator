# 共通処理設計書

## 文書情報

| 項目 | 内容 |
|------|------|
| プロジェクト名 | Multi-Mode Calculator |
| 文書バージョン | 1.0 |
| 作成日 | 2025-12-11 |
| 最終更新日 | 2025-12-11 |
| 作成者 | Claude Code |

---

## 1. 概要

本書では、複数モジュールで共通して使用するユーティリティ関数、定数、パターンについて定義する。

---

## 2. 共通定数

### 2.1 アプリケーション定数

```javascript
/**
 * アプリケーション共通定数
 */
const APP_CONSTANTS = {
  // アプリケーション名
  APP_NAME: 'Multi-Mode Calculator',

  // バージョン
  VERSION: '1.0.0',

  // LocalStorageプレフィックス
  STORAGE_PREFIX: 'calc_'
};
```

### 2.2 数値制限定数

```javascript
/**
 * 数値処理の制限値
 */
const NUMERIC_LIMITS = {
  // 最大表示桁数
  MAX_DIGITS: 16,

  // 最大小数桁数
  MAX_DECIMAL_PLACES: 10,

  // 階乗の最大値
  MAX_FACTORIAL: 170,

  // 浮動小数点精度（これ以下は0とみなす）
  PRECISION: 1e-15,

  // 整数の最大安全値
  MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,

  // ビット長ごとの最大値
  BIT_MAX: {
    8: 0xFF,
    16: 0xFFFF,
    32: 0xFFFFFFFF,
    64: Number.MAX_SAFE_INTEGER  // JavaScriptの制限
  }
};
```

### 2.3 UI定数

```javascript
/**
 * UI関連の定数
 */
const UI_CONSTANTS = {
  // トースト表示時間（ミリ秒）
  TOAST_DURATION: 2000,

  // アニメーション時間（ミリ秒）
  ANIMATION_DURATION: 300,

  // 桁区切り文字
  THOUSAND_SEPARATOR: ',',

  // プログラマモードの区切り文字
  PROGRAMMER_SEPARATOR: ' '
};
```

---

## 3. ユーティリティ関数

### 3.1 数値フォーマット

```javascript
/**
 * 数値を表示用にフォーマット
 * @param {number} num - フォーマットする数値
 * @returns {string} フォーマット済みの文字列
 */
function formatNumber(num) {
  // 非常に小さい値は0に丸める
  if (Math.abs(num) < NUMERIC_LIMITS.PRECISION) {
    return '0';
  }

  // 整数ならそのまま
  if (Number.isInteger(num)) {
    return num.toString();
  }

  // 小数は有効桁数を制限
  const str = num.toPrecision(NUMERIC_LIMITS.MAX_DIGITS);
  return parseFloat(str).toString();
}

/**
 * 3桁ごとにカンマを追加
 * @param {string} value - 数値文字列
 * @returns {string} カンマ区切りの文字列
 */
function addThousandsSeparator(value) {
  const isNegative = value.startsWith('-');
  const absValue = isNegative ? value.slice(1) : value;
  const [intPart, decPart] = absValue.split('.');

  const formattedInt = intPart.replace(/\B(?=(\d{3})+(?!\d))/g, UI_CONSTANTS.THOUSAND_SEPARATOR);

  let result = formattedInt;
  if (decPart !== undefined) {
    result += '.' + decPart;
  }
  if (isNegative) {
    result = '-' + result;
  }

  return result;
}

/**
 * 2進数を4桁区切りでフォーマット
 * @param {string} binary - 2進数文字列
 * @returns {string} フォーマット済みの文字列
 */
function formatBinary(binary) {
  const padLength = Math.ceil(binary.length / 4) * 4;
  const padded = binary.padStart(padLength, '0');
  return padded.match(/.{1,4}/g).join(' ');
}
```

### 3.2 進数変換

```javascript
/**
 * 進数変換
 * @param {string} value - 変換元の値
 * @param {number} fromBase - 変換元の基数
 * @param {number} toBase - 変換先の基数
 * @returns {string} 変換後の値
 */
function convertBase(value, fromBase, toBase) {
  const decimal = parseInt(value, fromBase);
  if (isNaN(decimal)) {
    return '0';
  }
  return decimal.toString(toBase).toUpperCase();
}

/**
 * ビットマスクを取得
 * @param {number} bitLength - ビット長
 * @returns {number} ビットマスク
 */
function getBitMask(bitLength) {
  return NUMERIC_LIMITS.BIT_MAX[bitLength] || 0xFFFFFFFF;
}

/**
 * 値をビット長に収める
 * @param {number} value - 数値
 * @param {number} bitLength - ビット長
 * @returns {number} クランプされた値
 */
function clampToBitLength(value, bitLength) {
  const mask = getBitMask(bitLength);
  return value & mask;
}
```

### 3.3 角度変換

```javascript
/**
 * 度をラジアンに変換
 * @param {number} degrees - 度数
 * @returns {number} ラジアン
 */
function degreesToRadians(degrees) {
  return degrees * (Math.PI / 180);
}

/**
 * ラジアンを度に変換
 * @param {number} radians - ラジアン
 * @returns {number} 度数
 */
function radiansToDegrees(radians) {
  return radians * (180 / Math.PI);
}
```

### 3.4 入力検証

```javascript
/**
 * 数字入力の検証
 * @param {string} char - 入力文字
 * @param {number} base - 現在の進数
 * @returns {boolean} 有効な入力かどうか
 */
function isValidDigit(char, base) {
  const patterns = {
    2: /^[01]$/,
    8: /^[0-7]$/,
    10: /^[0-9]$/,
    16: /^[0-9A-Fa-f]$/
  };
  return patterns[base]?.test(char) ?? false;
}

/**
 * 計算結果の検証
 * @param {number} result - 計算結果
 * @returns {{ valid: boolean, error: string|null }}
 */
function validateResult(result) {
  if (isNaN(result)) {
    return { valid: false, error: 'Error' };
  }
  if (!isFinite(result)) {
    return { valid: false, error: 'Infinity' };
  }
  return { valid: true, error: null };
}
```

### 3.5 数学関数

```javascript
/**
 * 階乗計算
 * @param {number} n - 非負整数
 * @returns {number|null} 階乗の結果、エラー時はnull
 */
function factorial(n) {
  if (n < 0 || !Number.isInteger(n)) {
    return null;
  }
  if (n > NUMERIC_LIMITS.MAX_FACTORIAL) {
    return Infinity;
  }
  if (n <= 1) return 1;

  let result = 1;
  for (let i = 2; i <= n; i++) {
    result *= i;
  }
  return result;
}

/**
 * 安全な除算
 * @param {number} a - 被除数
 * @param {number} b - 除数
 * @returns {number} 商（0除算の場合はNaN）
 */
function safeDivide(a, b) {
  if (b === 0) return NaN;
  return a / b;
}
```

### 3.6 LocalStorage操作

```javascript
/**
 * LocalStorageから安全に読み込み
 * @param {string} key - キー名
 * @param {*} defaultValue - デフォルト値
 * @returns {*} 読み込んだ値またはデフォルト値
 */
function loadFromStorage(key, defaultValue) {
  try {
    const value = localStorage.getItem(APP_CONSTANTS.STORAGE_PREFIX + key);
    return value !== null ? value : defaultValue;
  } catch (e) {
    console.error(`Failed to load ${key} from storage:`, e);
    return defaultValue;
  }
}

/**
 * LocalStorageに安全に保存
 * @param {string} key - キー名
 * @param {*} value - 保存する値
 * @returns {boolean} 成功したかどうか
 */
function saveToStorage(key, value) {
  try {
    localStorage.setItem(APP_CONSTANTS.STORAGE_PREFIX + key, value);
    return true;
  } catch (e) {
    console.error(`Failed to save ${key} to storage:`, e);
    return false;
  }
}

/**
 * LocalStorageからJSON配列を読み込み
 * @param {string} key - キー名
 * @returns {Array} 配列（エラー時は空配列）
 */
function loadArrayFromStorage(key) {
  try {
    const json = localStorage.getItem(APP_CONSTANTS.STORAGE_PREFIX + key);
    if (json) {
      const parsed = JSON.parse(json);
      if (Array.isArray(parsed)) {
        return parsed;
      }
    }
  } catch (e) {
    console.error(`Failed to parse ${key} from storage:`, e);
  }
  return [];
}

/**
 * LocalStorageにJSON配列を保存
 * @param {string} key - キー名
 * @param {Array} array - 保存する配列
 * @returns {boolean} 成功したかどうか
 */
function saveArrayToStorage(key, array) {
  try {
    const json = JSON.stringify(array);
    localStorage.setItem(APP_CONSTANTS.STORAGE_PREFIX + key, json);
    return true;
  } catch (e) {
    console.error(`Failed to save ${key} to storage:`, e);
    return false;
  }
}
```

### 3.7 クリップボード操作

```javascript
/**
 * クリップボードにテキストをコピー
 * @param {string} text - コピーするテキスト
 * @returns {Promise<boolean>} 成功したかどうか
 */
async function copyToClipboard(text) {
  try {
    // Clipboard API を試行
    await navigator.clipboard.writeText(text);
    return true;
  } catch (e) {
    // フォールバック: execCommand
    try {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      textarea.style.left = '-9999px';
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);
      return true;
    } catch (fallbackError) {
      console.error('Failed to copy to clipboard:', fallbackError);
      return false;
    }
  }
}
```

### 3.8 ID生成

```javascript
/**
 * 一意のIDを生成
 * @param {string} prefix - プレフィックス
 * @returns {string} 生成されたID
 */
function generateId(prefix = 'id') {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substr(2, 9);
  return `${prefix}_${timestamp}_${random}`;
}
```

### 3.9 日時フォーマット

```javascript
/**
 * タイムスタンプを表示用にフォーマット
 * @param {number} timestamp - Unixタイムスタンプ（ミリ秒）
 * @returns {string} フォーマットされた日時
 */
function formatTimestamp(timestamp) {
  const date = new Date(timestamp);
  const now = new Date();

  // 今日
  if (date.toDateString() === now.toDateString()) {
    return date.toLocaleTimeString('ja-JP', {
      hour: '2-digit',
      minute: '2-digit'
    });
  }

  // 今年
  if (date.getFullYear() === now.getFullYear()) {
    return date.toLocaleDateString('ja-JP', {
      month: 'short',
      day: 'numeric'
    }) + ' ' + date.toLocaleTimeString('ja-JP', {
      hour: '2-digit',
      minute: '2-digit'
    });
  }

  // それ以外
  return date.toLocaleDateString('ja-JP');
}
```

### 3.10 トースト通知

```javascript
/**
 * トースト通知を表示
 * @param {string} message - 表示するメッセージ
 * @param {number} duration - 表示時間（ミリ秒）
 */
function showToast(message, duration = UI_CONSTANTS.TOAST_DURATION) {
  // 既存のトーストを削除
  const existingToast = document.querySelector('.toast');
  if (existingToast) {
    existingToast.remove();
  }

  // トースト要素を作成
  const toast = document.createElement('div');
  toast.className = 'toast';
  toast.textContent = message;
  toast.setAttribute('role', 'alert');
  toast.setAttribute('aria-live', 'polite');
  document.body.appendChild(toast);

  // 表示アニメーション
  requestAnimationFrame(() => {
    toast.classList.add('toast--show');
  });

  // 自動非表示
  setTimeout(() => {
    toast.classList.remove('toast--show');
    setTimeout(() => toast.remove(), UI_CONSTANTS.ANIMATION_DURATION);
  }, duration);
}
```

---

## 4. 共通パターン

### 4.1 イベントデリゲーション

```javascript
/**
 * イベントデリゲーションのパターン
 *
 * 親要素にイベントリスナーを設定し、子要素のイベントを
 * 効率的に処理する
 */

// 例: ボタンコンテナへのイベント設定
document.querySelector('.calculator__buttons')
  .addEventListener('click', (event) => {
    const button = event.target.closest('button');
    if (!button) return;

    const action = button.dataset.action;
    const value = button.dataset.value;

    // アクションに応じた処理
    handleButtonAction(action, value);
  });
```

### 4.2 DOM要素キャッシュ

```javascript
/**
 * DOM要素キャッシュのパターン
 *
 * 頻繁にアクセスするDOM要素をキャッシュして
 * パフォーマンスを向上させる
 */

const elements = {
  display: null,
  buttons: null,
  // ...
};

function cacheElements() {
  elements.display = document.getElementById('display-main');
  elements.buttons = document.querySelector('.calculator__buttons');
  // ...
}

// 初期化時に一度だけ呼び出す
function init() {
  cacheElements();
  // ...
}
```

### 4.3 状態管理

```javascript
/**
 * 状態管理のパターン
 *
 * プライベートな状態オブジェクトと
 * 公開されたゲッター/セッターで管理
 */

const state = {
  value: null,
  // ...
};

function getValue() {
  return state.value;
}

function setValue(newValue) {
  // バリデーション
  if (!isValid(newValue)) {
    return false;
  }

  // 状態更新
  state.value = newValue;

  // 副作用（表示更新、保存など）
  updateDisplay();
  saveToStorage();

  return true;
}
```

### 4.4 エラーハンドリング

```javascript
/**
 * エラーハンドリングのパターン
 */

// 計算処理のエラーハンドリング
function safeCalculate(expression) {
  try {
    const result = calculate(expression);
    const validation = validateResult(result);

    if (!validation.valid) {
      return { success: false, error: validation.error };
    }

    return { success: true, value: result };
  } catch (e) {
    console.error('Calculation error:', e);
    return { success: false, error: 'Error' };
  }
}

// LocalStorage操作のエラーハンドリング
function safeStorageOperation(operation) {
  try {
    return operation();
  } catch (e) {
    console.error('Storage error:', e);
    return null;
  }
}
```

---

## 5. アクセシビリティ対応

### 5.1 aria属性の動的更新

```javascript
/**
 * パネル/ダイアログ表示時のaria属性更新
 */
function showPanel(element) {
  element.classList.add('is-open');
  element.setAttribute('aria-hidden', 'false');
}

function hidePanel(element) {
  element.classList.remove('is-open');
  element.setAttribute('aria-hidden', 'true');
}
```

### 5.2 フォーカス管理

```javascript
/**
 * モーダル/パネル内のフォーカストラップ
 */
function trapFocus(element) {
  const focusableElements = element.querySelectorAll(
    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
  );
  const firstFocusable = focusableElements[0];
  const lastFocusable = focusableElements[focusableElements.length - 1];

  element.addEventListener('keydown', (e) => {
    if (e.key !== 'Tab') return;

    if (e.shiftKey) {
      if (document.activeElement === firstFocusable) {
        lastFocusable.focus();
        e.preventDefault();
      }
    } else {
      if (document.activeElement === lastFocusable) {
        firstFocusable.focus();
        e.preventDefault();
      }
    }
  });
}
```

### 5.3 ライブリージョン

```javascript
/**
 * 計算結果の読み上げ対応
 */
function announceResult(result) {
  const liveRegion = document.getElementById('live-region');
  if (liveRegion) {
    liveRegion.textContent = `計算結果: ${result}`;
  }
}
```

---

## 6. パフォーマンス考慮

### 6.1 デバウンス

```javascript
/**
 * デバウンス関数
 * @param {Function} func - 実行する関数
 * @param {number} wait - 待機時間（ミリ秒）
 * @returns {Function} デバウンスされた関数
 */
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}
```

### 6.2 DOM更新の最適化

```javascript
/**
 * requestAnimationFrameを使用したDOM更新
 */
function scheduleUpdate(updateFn) {
  if (window.requestAnimationFrame) {
    window.requestAnimationFrame(updateFn);
  } else {
    updateFn();
  }
}
```

---

## 変更履歴

| 日付 | バージョン | 変更内容 | 変更者 |
|------|------------|----------|--------|
| 2025-12-11 | 1.0 | 初版作成 | Claude Code |
